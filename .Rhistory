use_twfe_residualization = TRUE, # controls + unit/time FE
return_setup = FALSE) {
# Defensive checks
if (!requireNamespace("synthdid", quietly = TRUE)) {
stop("Package `synthdid` is required.")
}
df2 <- df
# Coerce and standardize time
df2 <- df2 %>%
dplyr::mutate(
.unit = as.factor(.data[[unit]]),
.time_raw = .data[[time]],
.time = if (inherits(.data[[time]], "Date")) as.integer(.data[[time]])
else suppressWarnings(as.numeric(as.character(.data[[time]])))
)
if (anyNA(df2$.time)) stop("Time coercion produced NA values. Ensure `time` is numeric/character-numeric or Date.")
# Treatment indicator
df2 <- df2 %>%
dplyr::mutate(.W = as.integer((.data[[treated_unit]] == 1) & (.time >= treat_start_time)))
# Optional covariate adjustment: residualize y on controls (and optionally TWFE)
if (!is.null(controls)) {
if (!requireNamespace("fixest", quietly = TRUE)) {
stop("To use `controls`, please install `fixest` (install.packages('fixest')).")
}
# Build RHS for controls
controls_rhs <- ""
if (inherits(controls, "formula")) {
controls_rhs <- gsub("^\\s*~\\s*", "", deparse(controls))
} else if (is.character(controls)) {
controls_rhs <- paste(controls, collapse = " + ")
} else {
stop("`controls` must be NULL, a character vector of column names, or a one-sided formula like ~ x1 + x2.")
}
# Residualization regression
# Default: y ~ controls | unit + time  (TWFE residualization)
if (use_twfe_residualization) {
fml_txt <- paste0(y, " ~ ", controls_rhs, " | .unit + .time")
} else {
# Alternative: y ~ controls (no FE) — usually not recommended for panel SDID
fml_txt <- paste0(y, " ~ ", controls_rhs)
}
df2 <- df2 %>% dplyr::mutate(.rowid = dplyr::row_number())
m_resid <- fixest::feols(stats::as.formula(fml_txt), data = df2)
res_df <- tibble::tibble(
.rowid = as.integer(names(resid(m_resid))),
.y_resid = as.numeric(resid(m_resid))
)
df2 <- df2 %>% dplyr::left_join(res_df, by = ".rowid")
# Drop rows that were not used by feols (recommended for SDID; keeps balance check honest)
df2 <- df2 %>% dplyr::filter(!is.na(.y_resid)) %>% dplyr::mutate(!!y := .y_resid)
# cleanup
df2 <- df2 %>% dplyr::select(-.rowid, -.y_resid)
# Replace outcome with residualized outcome
df2[[y]] <- resid(m_resid)
}
# Prepare panel for synthdid
dfp <- df2 %>%
dplyr::arrange(.unit, .time) %>%
dplyr::select(.unit, .time, !!y, .W) %>%
dplyr::rename(y = !!y)
dfp <- as.data.frame(dfp)
# Balance check (panel.matrices requires balanced panel)
# This check is cheap and gives a clearer error than panel.matrices.
bad <- dfp %>%
dplyr::count(.unit, .time) %>%
dplyr::filter(n != 1)
if (nrow(bad) > 0) {
stop("Input must be a balanced panel with unique (.unit, .time) rows. Found duplicates/missingness.")
}
setup <- synthdid::panel.matrices(dfp)
est <- synthdid::synthdid_estimate(setup$Y, setup$N0, setup$T0)
if (return_setup) {
return(list(estimate = est, setup = setup))
} else {
return(est)
}
}
make_weighted_treated_unit <- function(df, treat_start_time, weight_col = "pop") {
baseline_time <- treat_start_time - 1
# compute synthetic id BEFORE summarise
max_id <- max(as.integer(df$unit), na.rm = TRUE)
synth_id <- max_id + 1L
w0 <- df %>%
filter(time == baseline_time) %>%
select(unit, !!rlang::sym(weight_col)) %>%
rename(w0 = !!rlang::sym(weight_col))
df2 <- df %>% left_join(w0, by = "unit")
treated <- df2 %>% filter(treated_unit == 1)
controls <- df2 %>% filter(treated_unit == 0)
treated_super <- treated %>%
dplyr::group_by(time) %>%
dplyr::summarise(
y = sum(y * w0, na.rm = TRUE) / sum(w0, na.rm = TRUE),
treated_unit = 1L,
post = as.integer(dplyr::first(time) >= treat_start_time),
.groups = "drop"
) %>%
dplyr::mutate(unit = synth_id)
bind_rows(controls, treated_super)
}
run_sdid_by_treated_and_average <- function(df, treat_start_time, weight_col = "pop") {
baseline_time <- treat_start_time - 1
treated_ids <- df %>% filter(treated_unit == 1) %>% distinct(unit) %>% pull(unit)
controls_df <- df %>% filter(treated_unit == 0)
weights <- df %>%
filter(treated_unit == 1, time == baseline_time) %>%
group_by(unit) %>%
summarise(w0 = mean(.data[[weight_col]], na.rm = TRUE), .groups = "drop")
est <- map_dfr(treated_ids, function(id) {
dfi <- bind_rows(controls_df, df %>% filter(unit == id))
tau <- run_sdid_long(dfi, treat_start_time)
tibble(unit = id, tau = as.numeric(tau))
}) %>%
left_join(weights, by = "unit")
tau_wavg <- sum(est$tau * est$w0, na.rm = TRUE) / sum(est$w0, na.rm = TRUE)
list(unit_level = est, tau_weighted_average = tau_wavg)
}
## Data (created previously)
data_path <- normalizePath(file.path("..", "data", "analysis_data.csv"), mustWork = FALSE)
## Check to make sure data exist
if (!is.na(data_path)) {
message("Loading data: ", data_path)
panel <- read_csv(data_path, show_col_types = FALSE)
## Define control variables
control_vars <- c("pct_white", "pop_20_64", "pct_55_64", "log_35_44", "log_f_20_64", "unemp")
## Basic version for now, with controls to come
panel <- panel %>% dplyr::select(time = year,
unit = fips,
y = crude_rate,
treated_unit = treated,
pop = population,
control_vars )
required <- c("unit", "time", "y", "treated_unit")
if (!all(required %in% names(panel))) {
stop("Replication data found, but missing required columns: unit, time, y, treated_unit (and optional pop).")
}
# You should set this explicitly for the application:
T0_emp <- min(panel$time[panel$treated_unit == 1], na.rm = TRUE)
panel <- panel %>% mutate(post = as.integer(time >= T0_emp))
## Estimate models (unweighted) (SDID)
tau_emp_sdid <- run_sdid_long(panel, T0_emp)
tau_emp_sdid_controls <- run_sdid_long(panel, T0_emp, controls = control_vars)
## Estimated Models (unweighted) (DiD)
tau_emp_did_unw <- did_twfe(df)
tau_emp_did_unw_controls <- tau <- did_twfe(df, controls = control_vars)
out <- tibble(
method = c("SDID (UnW)","SDID (UnW) (Controls)", "DID (UnW)","DID (UnW) (Controls)"),
tau = c(as.numeric(tau_emp_sdid),as.numeric(tau_emp_sdid_controls), as.numeric(tau_emp_did_unw),as.numeric(tau_emp_did_unw_controls))
)
if ("pop" %in% names(panel)) {
df_super <- make_weighted_treated_unit(panel, T0_emp, weight_col = "pop")
tau_emp_sdid_super <- run_sdid_long(df_super, T0_emp)
sol2 <- run_sdid_by_treated_and_average(panel, T0_emp, weight_col = "pop")
tau_emp_did_w <- did_2x2(panel, w = "pop")
out <- bind_rows(out, tibble(
method = c("SDID weighted treated avg (Sol. 1)", "Weighted avg of unit SDIDs (Sol. 2)", "DID (weighted)"),
tau = c(as.numeric(tau_emp_sdid_super), as.numeric(sol2$tau_weighted_average), as.numeric(tau_emp_did_w))
))
}
knitr::kable(out, digits = 3, caption = "Replication: SDID/DID estimates (placeholder)")
} else {
cat("No replication data found. Put data/analysis_panel.csv or data/analysis_panel.rds in the repo to enable this section.")
}
did_twfe <- function(df,
y = "y",
treated_unit = "treated_unit",
post = "post",
unit = "unit",
time = "time",
controls = NULL,      # NULL, character vector, or one-sided formula
w = NULL,             # NULL or weight column name
cluster = "unit",     # NULL, or column name (or a ~formula string)
return_model = FALSE) {
if (!requireNamespace("fixest", quietly = TRUE)) {
stop("Package `fixest` is required. Install via install.packages('fixest').")
}
# Controls -> RHS string
controls_rhs <- ""
if (!is.null(controls)) {
if (inherits(controls, "formula")) {
# e.g., controls = ~ x1 + x2 + i(region)
# Convert formula to text and drop leading "~"
controls_rhs <- paste0(" + ", gsub("^\\s*~\\s*", "", deparse(controls)))
} else if (is.character(controls)) {
# e.g., controls = c("x1","x2")
controls_rhs <- paste0(" + ", paste(controls, collapse = " + "))
} else {
stop("`controls` must be NULL, a character vector of column names, or a one-sided formula like ~ x1 + x2.")
}
}
# Main formula: y ~ treated*post + controls | unit + time
fml_txt <- paste0(
y, " ~ ", treated_unit, " * ", post,
controls_rhs,
" | ", unit, " + ", time
)
fml <- stats::as.formula(fml_txt)
# Weights vector (optional)
weights_vec <- if (is.null(w)) NULL else df[[w]]
# Cluster handling
cluster_fml <- NULL
if (!is.null(cluster)) {
if (inherits(cluster, "formula")) {
cluster_fml <- cluster
} else if (is.character(cluster)) {
cluster_fml <- stats::as.formula(paste0("~", cluster))
} else {
stop("`cluster` must be NULL, a column name (character), or a formula like ~unit.")
}
}
m <- fixest::feols(
fml,
data = df,
weights = weights_vec,
cluster = cluster_fml
)
# Extract interaction coefficient
cn <- names(stats::coef(m))
target <- paste0(treated_unit, ":", post)
if (!target %in% cn) {
target2 <- paste0(post, ":", treated_unit)
if (target2 %in% cn) {
target <- target2
} else {
stop("Could not find interaction coefficient. Coef names: ", paste(cn, collapse = ", "))
}
}
tau_hat <- unname(stats::coef(m)[[target]])
if (return_model) list(tau_hat = tau_hat, model = m, formula = fml) else tau_hat
}
run_sdid_long <- function(df,
treat_start_time,
controls = NULL,     # NULL, character vector, or one-sided formula
unit = "unit",
time = "time",
y = "y",
treated_unit = "treated_unit",
use_twfe_residualization = TRUE, # controls + unit/time FE
return_setup = FALSE) {
# Defensive checks
if (!requireNamespace("synthdid", quietly = TRUE)) {
stop("Package `synthdid` is required.")
}
df2 <- df
# Coerce and standardize time
df2 <- df2 %>%
dplyr::mutate(
.unit = as.factor(.data[[unit]]),
.time_raw = .data[[time]],
.time = if (inherits(.data[[time]], "Date")) as.integer(.data[[time]])
else suppressWarnings(as.numeric(as.character(.data[[time]])))
)
if (anyNA(df2$.time)) stop("Time coercion produced NA values. Ensure `time` is numeric/character-numeric or Date.")
# Treatment indicator
df2 <- df2 %>%
dplyr::mutate(.W = as.integer((.data[[treated_unit]] == 1) & (.time >= treat_start_time)))
# Optional covariate adjustment: residualize y on controls (and optionally TWFE)
if (!is.null(controls)) {
if (!requireNamespace("fixest", quietly = TRUE)) {
stop("To use `controls`, please install `fixest` (install.packages('fixest')).")
}
# Build RHS for controls
controls_rhs <- ""
if (inherits(controls, "formula")) {
controls_rhs <- gsub("^\\s*~\\s*", "", deparse(controls))
} else if (is.character(controls)) {
controls_rhs <- paste(controls, collapse = " + ")
} else {
stop("`controls` must be NULL, a character vector of column names, or a one-sided formula like ~ x1 + x2.")
}
# Residualization regression
# Default: y ~ controls | unit + time  (TWFE residualization)
if (use_twfe_residualization) {
fml_txt <- paste0(y, " ~ ", controls_rhs, " | .unit + .time")
} else {
# Alternative: y ~ controls (no FE) — usually not recommended for panel SDID
fml_txt <- paste0(y, " ~ ", controls_rhs)
}
# Run regression
m_resid <- fixest::feols(stats::as.formula(fml_txt), data = df2)
# Drop unmatched observations
df2 <- df2[fixest::obs(m_resid), , drop = FALSE]
# Replace outcome with residualized outcome
df2[[y]] <- as.numeric(stats::resid(m_resid))
}
# Prepare panel for synthdid
dfp <- df2 %>%
dplyr::arrange(.unit, .time) %>%
dplyr::select(.unit, .time, !!y, .W) %>%
dplyr::rename(y = !!y)
dfp <- as.data.frame(dfp)
# Balance check (panel.matrices requires balanced panel)
# This check is cheap and gives a clearer error than panel.matrices.
bad <- dfp %>%
dplyr::count(.unit, .time) %>%
dplyr::filter(n != 1)
if (nrow(bad) > 0) {
stop("Input must be a balanced panel with unique (.unit, .time) rows. Found duplicates/missingness.")
}
setup <- synthdid::panel.matrices(dfp)
est <- synthdid::synthdid_estimate(setup$Y, setup$N0, setup$T0)
if (return_setup) {
return(list(estimate = est, setup = setup))
} else {
return(est)
}
}
make_weighted_treated_unit <- function(df, treat_start_time, weight_col = "pop") {
baseline_time <- treat_start_time - 1
# compute synthetic id BEFORE summarise
max_id <- max(as.integer(df$unit), na.rm = TRUE)
synth_id <- max_id + 1L
w0 <- df %>%
filter(time == baseline_time) %>%
select(unit, !!rlang::sym(weight_col)) %>%
rename(w0 = !!rlang::sym(weight_col))
df2 <- df %>% left_join(w0, by = "unit")
treated <- df2 %>% filter(treated_unit == 1)
controls <- df2 %>% filter(treated_unit == 0)
treated_super <- treated %>%
dplyr::group_by(time) %>%
dplyr::summarise(
y = sum(y * w0, na.rm = TRUE) / sum(w0, na.rm = TRUE),
treated_unit = 1L,
post = as.integer(dplyr::first(time) >= treat_start_time),
.groups = "drop"
) %>%
dplyr::mutate(unit = synth_id)
bind_rows(controls, treated_super)
}
run_sdid_by_treated_and_average <- function(df, treat_start_time, weight_col = "pop") {
baseline_time <- treat_start_time - 1
treated_ids <- df %>% filter(treated_unit == 1) %>% distinct(unit) %>% pull(unit)
controls_df <- df %>% filter(treated_unit == 0)
weights <- df %>%
filter(treated_unit == 1, time == baseline_time) %>%
group_by(unit) %>%
summarise(w0 = mean(.data[[weight_col]], na.rm = TRUE), .groups = "drop")
est <- map_dfr(treated_ids, function(id) {
dfi <- bind_rows(controls_df, df %>% filter(unit == id))
tau <- run_sdid_long(dfi, treat_start_time)
tibble(unit = id, tau = as.numeric(tau))
}) %>%
left_join(weights, by = "unit")
tau_wavg <- sum(est$tau * est$w0, na.rm = TRUE) / sum(est$w0, na.rm = TRUE)
list(unit_level = est, tau_weighted_average = tau_wavg)
}
## Data (created previously)
data_path <- normalizePath(file.path("..", "data", "analysis_data.csv"), mustWork = FALSE)
## Check to make sure data exist
if (!is.na(data_path)) {
message("Loading data: ", data_path)
panel <- read_csv(data_path, show_col_types = FALSE)
## Define control variables
control_vars <- c("pct_white", "pop_20_64", "pct_55_64", "log_35_44", "log_f_20_64", "unemp")
## Basic version for now, with controls to come
panel <- panel %>% dplyr::select(time = year,
unit = fips,
y = crude_rate,
treated_unit = treated,
pop = population,
control_vars )
required <- c("unit", "time", "y", "treated_unit")
if (!all(required %in% names(panel))) {
stop("Replication data found, but missing required columns: unit, time, y, treated_unit (and optional pop).")
}
# You should set this explicitly for the application:
T0_emp <- min(panel$time[panel$treated_unit == 1], na.rm = TRUE)
panel <- panel %>% mutate(post = as.integer(time >= T0_emp))
## Estimate models (unweighted) (SDID)
tau_emp_sdid <- run_sdid_long(panel, T0_emp)
tau_emp_sdid_controls <- run_sdid_long(panel, T0_emp, controls = control_vars)
## Estimated Models (unweighted) (DiD)
tau_emp_did_unw <- did_twfe(df)
tau_emp_did_unw_controls <- tau <- did_twfe(df, controls = control_vars)
out <- tibble(
method = c("SDID (UnW)","SDID (UnW) (Controls)", "DID (UnW)","DID (UnW) (Controls)"),
tau = c(as.numeric(tau_emp_sdid),as.numeric(tau_emp_sdid_controls), as.numeric(tau_emp_did_unw),as.numeric(tau_emp_did_unw_controls))
)
if ("pop" %in% names(panel)) {
df_super <- make_weighted_treated_unit(panel, T0_emp, weight_col = "pop")
tau_emp_sdid_super <- run_sdid_long(df_super, T0_emp)
sol2 <- run_sdid_by_treated_and_average(panel, T0_emp, weight_col = "pop")
tau_emp_did_w <- did_2x2(panel, w = "pop")
out <- bind_rows(out, tibble(
method = c("SDID weighted treated avg (Sol. 1)", "Weighted avg of unit SDIDs (Sol. 2)", "DID (weighted)"),
tau = c(as.numeric(tau_emp_sdid_super), as.numeric(sol2$tau_weighted_average), as.numeric(tau_emp_did_w))
))
}
knitr::kable(out, digits = 3, caption = "Replication: SDID/DID estimates (placeholder)")
} else {
cat("No replication data found. Put data/analysis_panel.csv or data/analysis_panel.rds in the repo to enable this section.")
}
tau_emp_did_unw <- did_twfe(panel)
## Data (created previously)
data_path <- normalizePath(file.path("..", "data", "analysis_data.csv"), mustWork = FALSE)
## Check to make sure data exist
if (!is.na(data_path)) {
message("Loading data: ", data_path)
panel <- read_csv(data_path, show_col_types = FALSE)
## Define control variables
control_vars <- c("pct_white", "pop_20_64", "pct_55_64", "log_35_44", "log_f_20_64", "unemp")
## Basic version for now, with controls to come
panel <- panel %>% dplyr::select(time = year,
unit = fips,
y = crude_rate,
treated_unit = treated,
pop = population,
control_vars )
required <- c("unit", "time", "y", "treated_unit")
if (!all(required %in% names(panel))) {
stop("Replication data found, but missing required columns: unit, time, y, treated_unit (and optional pop).")
}
# You should set this explicitly for the application:
T0_emp <- min(panel$time[panel$treated_unit == 1], na.rm = TRUE)
panel <- panel %>% mutate(post = as.integer(time >= T0_emp))
## Estimate models (unweighted) (SDID)
tau_emp_sdid <- run_sdid_long(panel, T0_emp)
tau_emp_sdid_controls <- run_sdid_long(panel, T0_emp, controls = control_vars)
## Estimated Models (unweighted) (DiD)
tau_emp_did_unw <- did_twfe(panel)
tau_emp_did_unw_controls <- did_twfe(panel, controls = control_vars)
out <- tibble(
method = c("SDID (UnW)","SDID (UnW) (Controls)", "DID (UnW)","DID (UnW) (Controls)"),
tau = c(as.numeric(tau_emp_sdid),as.numeric(tau_emp_sdid_controls), as.numeric(tau_emp_did_unw),as.numeric(tau_emp_did_unw_controls))
)
if ("pop" %in% names(panel)) {
df_super <- make_weighted_treated_unit(panel, T0_emp, weight_col = "pop")
tau_emp_sdid_super <- run_sdid_long(df_super, T0_emp)
sol2 <- run_sdid_by_treated_and_average(panel, T0_emp, weight_col = "pop")
tau_emp_did_w <- did_2x2(panel, w = "pop")
out <- bind_rows(out, tibble(
method = c("SDID weighted treated avg (Sol. 1)", "Weighted avg of unit SDIDs (Sol. 2)", "DID (weighted)"),
tau = c(as.numeric(tau_emp_sdid_super), as.numeric(sol2$tau_weighted_average), as.numeric(tau_emp_did_w))
))
}
knitr::kable(out, digits = 3, caption = "Replication: SDID/DID estimates (placeholder)")
} else {
cat("No replication data found. Put data/analysis_panel.csv or data/analysis_panel.rds in the repo to enable this section.")
}
names(panel)
controls_rhs <- ""
fml_txt <- paste0(
y, " ~ ", treated_unit, " * ", post,
controls_rhs,
" | ", unit, " + ", time
)
summary(panel)
table(panel$treated_unit, useNA = "ifany")
table(panel$post, useNA = "ifany")
with(panel, table(treated_unit, post, useNA = "ifany"))
panel <- read_csv(data_path, show_col_types = FALSE)
## Define control variables
control_vars <- c("pct_white", "pop_20_64", "pct_55_64", "log_35_44", "log_f_20_64", "unemp")
## Basic version for now, with controls to come
panel <- panel %>% dplyr::select(time = year,
unit = fips,
y = crude_rate,
treated_unit = expansion,
pop = population,
control_vars )
required <- c("unit", "time", "y", "treated_unit")
if (!all(required %in% names(panel))) {
stop("Replication data found, but missing required columns: unit, time, y, treated_unit (and optional pop).")
}
# You should set this explicitly for the application:
T0_emp <- min(panel$time[panel$treated_unit == 1], na.rm = TRUE)
panel <- panel %>% mutate(post = as.integer(time >= T0_emp))
## Estimate models (unweighted) (SDID)
tau_emp_sdid <- run_sdid_long(panel, T0_emp)
panel <- read_csv(data_path, show_col_types = FALSE)
## Define control variables
control_vars <- c("pct_white", "pop_20_64", "pct_55_64", "log_35_44", "log_f_20_64", "unemp")
## Basic version for now, with controls to come
panel <- panel %>% dplyr::select(time = year,
unit = fips,
y = crude_rate,
treated_unit = expansion,
pop = population,
control_vars )
T0_emp
panel <- read_csv(data_path, show_col_types = FALSE)
## Define control variables
control_vars <- c("pct_white", "pop_20_64", "pct_55_64", "log_35_44", "log_f_20_64", "unemp")
## Basic version for now, with controls to come
panel <- panel %>% dplyr::select(time = year,
unit = fips,
y = crude_rate,
treated_unit = expansion,
pop = population,
control_vars )
required <- c("unit", "time", "y", "treated_unit")
if (!all(required %in% names(panel))) {
stop("Replication data found, but missing required columns: unit, time, y, treated_unit (and optional pop).")
}
# You should set this explicitly for the application:
T0_emp <- 2014
panel <- panel %>% mutate(post = as.integer(time >= T0_emp))
## Estimate models (unweighted) (SDID)
tau_emp_sdid <- run_sdid_long(panel, T0_emp)
tau_emp_sdid_controls <- run_sdid_long(panel, T0_emp, controls = control_vars)
## Estimated Models (unweighted) (DiD)
tau_emp_did_unw <- did_twfe(panel)
tau_emp_did_unw_controls <- did_twfe(panel, controls = control_vars)
out <- tibble(
method = c("SDID (UnW)","SDID (UnW) (Controls)", "DID (UnW)","DID (UnW) (Controls)"),
tau = c(as.numeric(tau_emp_sdid),as.numeric(tau_emp_sdid_controls), as.numeric(tau_emp_did_unw),as.numeric(tau_emp_did_unw_controls))
)
View(out)
df_super <- make_weighted_treated_unit(panel, T0_emp, weight_col = "pop")
tau_emp_sdid_super <- run_sdid_long(df_super, T0_emp)
sol2 <- run_sdid_by_treated_and_average(panel, T0_emp, weight_col = "pop")
